(()=>{let t;function s(t,s,e){return i=>{var o;let h=function(t,s,e,i,o){let h=function(t,s=null,e=null){return t=null!==e?Math.min(t,e):t,t=null!==s?Math.max(t,s):t}(t,s,e);return 0+(o-0)/(e-s)*(h-s)}(i=((i-s)%(o=e-s)+o)%o+s,s,e,0,t.length-1),n=Math.floor(h),r=t[n];return r+(t[n+1]-r)*(h-n)}}s([1,.99179,.96729,.92692,.87132,.80141,.71835,.62349,.51839,.40478,.28453,.1596,.03205,-.09602,-.22252,-.34537,-.46254,-.57212,-.6723,-.76145,-.83809,-.90097,-.94906,-.98156,-.99795,-.99795,-.98156,-.94906,-.90097,-.83809,-.76145,-.6723,-.57212,-.46254,-.34537,-.22252,-.09602,.03205,.1596,.28453,.40478,.51839,.62349,.71835,.80141,.87132,.92692,.96729,.99179,1],0,2*Math.PI),s([0,.12788,.25365,.37527,.49072,.59811,.69568,.78183,.85514,.91441,.95867,.98718,.99949,.99538,.97493,.93847,.8866,.82017,.74028,.64823,.54553,.43388,.31511,.19116,.06407,-.06407,-.19116,-.31511,-.43388,-.54553,-.64823,-.74028,-.82017,-.8866,-.93847,-.97493,-.99538,-.99949,-.98718,-.95867,-.91441,-.85514,-.78183,-.69568,-.59811,-.49072,-.37527,-.25365,-.12788,-0],0,2*Math.PI);class e{constructor(t,s){this.x=t,this.y=s}add(t){return new e(this.x+t.x,this.y+t.y)}sub(t){return new e(this.x-t.x,this.y-t.y)}mult(t){return new e(this.x*t,this.y*t)}angle(){return Math.atan2(this.y,this.x)}setMag(t){let s=this.angle();return new e(Math.cos(s)*t,Math.sin(s)*t)}static fromAngle(t){return new e(Math.cos(t),Math.sin(t))}static dist(t,s){return Math.sqrt((t.x-s.x)**2+(t.y-s.y)**2)}toJSON(){return{x:this.x,y:this.y}}static fromJSON(t){return new e(t.x,t.y)}}class i{constructor(t,s){for(this.spacing=4,this.numDisturbances=30,this.thetaVariance=3.14,this.disturbanceRadiusMean=100,this.disturbanceRadiusVariance=200,this.disturbances=[],this.rng=t,this.bounds=s,this.defaultTheta=t.uniform(0,2*Math.PI),this.fieldPoints=[],this.disturbances=[];this.disturbances.length<this.numDisturbances;)this.addDisturbance();this.computeFlowField()}inBounds(t){return t.x>=0&&t.x<=this.bounds.x&&t.y>=0&&t.y<=this.bounds.y}addDisturbance(){let t=this.rng.uniform(0,this.bounds.x),s=this.rng.uniform(0,this.bounds.y),i=this.rng.gauss(0,this.thetaVariance),o=Math.abs(this.rng.gauss(this.disturbanceRadiusMean,this.disturbanceRadiusVariance)),h=this.rng.uniform(0,2*Math.PI),n=this.rng.uniform(0,.5),r=e.fromAngle(h).mult(n);this.disturbances.push({pos:new e(t,s),vel:r,theta:i,radius:o})}computeFlowField(){let t=Math.ceil(this.bounds.x/this.spacing),s=Math.ceil(this.bounds.y/this.spacing);for(let{pos:e,theta:i,radius:o}of(this.fieldPoints=Array.from({length:t},()=>new Float64Array(s).fill(this.defaultTheta)),this.disturbances)){let h=e.x-o,n=e.x+o,r=e.y-o,l=e.y+o,a=Math.max(0,Math.floor(h/this.spacing)),u=Math.min(t,Math.ceil(n/this.spacing)),c=Math.max(0,Math.floor(r/this.spacing)),m=Math.min(s,Math.ceil(l/this.spacing));for(let t=a;t<u;t++){let s=this.spacing*t;for(let h=c;h<m;h++){let n=this.spacing*h,r=e.x-s,l=e.y-n,a=Math.sqrt(r*r+l*l),u=a<=o?i*(1-a/o):0;this.fieldPoints[t][h]+=u}}}}step(){for(let t of this.disturbances)t.pos.add(t.vel),this.inBounds(t.pos)||t.vel.mult(-1);this.computeFlowField()}flow(t){let s=Math.floor(t.x/this.spacing),i=Math.floor(t.y/this.spacing),o=this.fieldPoints[s][i];return e.fromAngle(o)}}class o{constructor(){this._state=new Uint16Array(4),this._dv=new DataView(this._state.buffer),this._nG=null,this._hNG=!1}setSeed(t){this._hNG=!1,this._nG=null;let s=~~((t.length-2)/2),e=[];for(let i=0;i<s;i++){let s=2+2*i;e.push(parseInt(t.slice(s,s+2),16))}let i=h(e,1690382925),o=h(e,72970470);this._dv.setUint32(0,i),this._dv.setUint32(4,o)}rnd(){let t=this._state,s=t[0],e=t[1],i=t[2],o=t[3],h=33103+32557*s|0,n=63335+32557*e+(19605*s+(h>>>16))|0,r=31614+32557*i+19605*e+(62509*s+(n>>>16))|0,l=5125+32557*o+(19605*i+62509*e)+(22609*s+(r>>>16));t[0]=h,t[1]=n,t[2]=r,t[3]=l;let a=(o<<21)+((o>>2^i)<<5)+((i>>2^e)>>11);return 23283064365386963e-26*((a>>>(o>>11)|a<<(31&-(o>>11)))>>>0)}uniform(t=1,s=null){return null===s&&([t,s]=[0,t]),this.rnd()*(s-t)+t}gauss(t=0,s=1){if(this._hNG){this._hNG=!1;var e=this._nG;return this._nG=null,t+s*e}var i=0,o=0,h=0;do h=(i=2*this.rnd()-1)*i+(o=2*this.rnd()-1)*o;while(h>=1||0===h)var n=Math.sqrt(-2*Math.log(h)/h);return this._nG=o*n,this._hNG=!0,t+i*n*s}odds(t){return this.uniform()<=t}choice(t){return t[Math.floor(this.uniform(0,t.length))]}weightedChoice(t){let s=t.map(([,t])=>t).reduce((t,s)=>t+s,0)*this.uniform(),e=0;for(let i=0;i<t.length;i++){let[o,h]=t[i];if((e+=h)>=s)return o}let[i]=t[t.length-1];return i}wc(t){return this.weightedChoice(t)}shuffle(t){let s=t.map(t=>[this.uniform(0,1),t]);return s.sort((t,s)=>t[0]<s[0]?-1:1),s.map(([,t])=>t)}winnow(t,s){let e=t.slice();for(;e.length>s;){let t=Math.floor(this.rnd()*e.length);e.splice(t,1)}return e}}function h(t,s=0){for(var e,i=t.length,o=s^i,h=0;i>=4;)e=(65535&(e=255&t[h]|(255&t[++h])<<8|(255&t[++h])<<16|(255&t[++h])<<24))*1540483477+(((e>>>16)*1540483477&65535)<<16),e^=e>>>24,o=(65535&o)*1540483477+(((o>>>16)*1540483477&65535)<<16)^(e=(65535&e)*1540483477+(((e>>>16)*1540483477&65535)<<16)),i-=4,++h;switch(i){case 3:o^=(255&t[h+2])<<16;case 2:o^=(255&t[h+1])<<8;case 1:o^=255&t[h],o=(65535&o)*1540483477+(((o>>>16)*1540483477&65535)<<16)}return o^=o>>>13,o=(65535&o)*1540483477+(((o>>>16)*1540483477&65535)<<16),(o^=o>>>15)>>>0}class n{constructor(t,s){this.position=s,this.motes=new Set([t])}update(t){let s=new e(0,0);for(let i of this.motes)s=s.add(new e(t[4*i],t[4*i+1]));this.position=s.mult(1/this.motes.size)}toJSON(){return{position:this.position.toJSON(),motes:Array.from(this.motes)}}static fromJSON(t){let s=new n(-1,e.fromJSON(t.position));return s.motes=new Set(t.motes),s}}class r{constructor(t,s,h,n){this.clusters=[],this.stepCounter=0,this.spec=t,this.xMax=h,this.yMax=n,this.rng=function(t){let s=new o;return s.setSeed(t),s}(s),this.flowField=new i(this.rng,new e(h,n)),this.nMotes=t.numMotes,this.motes=new Float32Array(4*this.nMotes),this.velocities=new Float32Array(2*this.nMotes);for(let t=0;t<this.nMotes;t++)this.motes[4*t]=this.rng.uniform(0,this.xMax),this.motes[4*t+1]=this.rng.uniform(0,this.yMax),this.motes[4*t+2]=0,this.motes[4*t+3]=0;this.start=Date.now()}step(){return this.flowField.step(),this.reset(),this.processCollisions(),this.updateClusters(),this.applyClusterDynamics(),this.moveMotes(),this.stepCounter++}reset(){for(let t=0;t<this.nMotes;t++)(this.motes[4*t]<0||this.motes[4*t]>=this.xMax||this.motes[4*t+1]<0||this.motes[4*t+1]>=this.yMax)&&(this.motes[4*t]=this.rng.uniform(0,this.xMax),this.motes[4*t+1]=this.rng.uniform(0,this.yMax),this.motes[4*t+3]=this.stepCounter),this.motes[4*t+2]=0,this.velocities[2*t]=0,this.velocities[2*t+1]=0}processCollisions(){let t=2*this.spec.moteRadius,s=new Map,i=this.spec.moteRadius*this.spec.moteRadius;this.clusters.flatMap(t=>Array.from(t.motes));let o=new Map;this.clusters.forEach(t=>t.motes.forEach(s=>o.set(s,t)));for(let e=0;e<this.nMotes;e++){let i=Math.floor(this.motes[4*e]/t),o=Math.floor(this.motes[4*e+1]/t),h=`${i},${o}`;s.has(h)||s.set(h,[]),s.get(h).push(e)}for(let[t,h]of s.entries()){let[r,l]=t.split(",").map(Number);for(let t of[`${r},${l}`,`${r+1},${l}`,`${r-1},${l}`,`${r},${l+1}`,`${r},${l-1}`,`${r+1},${l+1}`,`${r-1},${l-1}`,`${r+1},${l-1}`,`${r-1},${l+1}`]){let r=s.get(t);if(r)for(let t of h){let s=o.get(t)??new n(t,new e(this.motes[4*t],this.motes[4*t+1])),h=!o.has(t);for(let n of r)if(t<n){let r=this.motes[4*n],l=this.motes[4*n+1],a=this.motes[4*n]-this.motes[4*t],u=this.motes[4*n+1]-this.motes[4*t+1],c=a*a+u*u,m=s.position.x-r,f=s.position.y-l,d=m*m+f*f;if(c<i){let s=new e(a,u),i=Math.sqrt(c);this.collide(t,n,i,s)}d<this.spec.clusterRadius*this.spec.clusterRadius&&(s.motes.add(n),h||o.set(n,s))}if(h&&s.motes.size>this.spec.clusterSize)for(let t of(this.clusters.push(s),s.motes))o.set(t,s)}}}}moveMotes(){for(let t=0;t<this.nMotes;t++){let s=this.flowField.flow(new e(this.motes[4*t],this.motes[4*t+1])),i=this.motes[4*t+2],o=Math.pow(this.spec.cxFlowCoefficient,i);s=s.mult(this.spec.flowCoefficient*o),this.motes[4*t]+=s.x+this.velocities[2*t],this.motes[4*t+1]+=s.y+this.velocities[2*t+1]}}updateClusters(){let t=new Set;for(let s=this.clusters.length-1;s>=0;s--){let i=this.clusters[s];for(let t of(i.update(this.motes),i.motes)){let s=new e(this.motes[4*t],this.motes[4*t+1]);e.dist(i.position,s)>this.spec.clusterRadius&&i.motes.delete(t)}i.motes.size<this.spec.clusterCollapseSize&&t.add(s)}for(let s=this.clusters.length-1;s>=0;s--){if(t.has(s))continue;let i=this.clusters[s];for(let o=s-1;o>=0;o--){if(t.has(o))continue;let s=this.clusters[o];e.dist(i.position,s.position)<this.spec.clusterRadius&&(i.motes=new Set([...i.motes,...s.motes]),i.update(this.motes),t.add(o))}}for(let s=this.clusters.length-1;s>=0;s--)t.has(s)&&this.clusters.splice(s,1)}applyClusterDynamics(){for(let t of this.clusters)for(let s of t.motes){let i=new e(this.motes[4*s],this.motes[4*s+1]),o=e.dist(i,t.position),h=t.position.sub(i),n=Math.min(o*this.spec.clusterCohesionFactor,this.spec.maxCohesionForce);h=h.setMag(n);let r=new e(0,0);if(o<this.spec.clusterSeparationRadius){r=i.sub(t.position);let s=this.spec.clusterSeparationFactor*(1-o/this.spec.clusterSeparationRadius);r=r.setMag(s)}let l=this.calculateClusterVelocity(t).sub(new e(this.velocities[2*s],this.velocities[2*s+1]));l=l.mult(this.spec.clusterAlignmentFactor);let a=h.add(r).add(l);this.velocities[2*s]+=a.x,this.velocities[2*s+1]+=a.y}}calculateClusterVelocity(t){let s=new e(0,0);for(let i of t.motes)s=s.add(new e(this.velocities[2*i],this.velocities[2*i+1]));return s.mult(1/t.motes.size)}collide(t,s,e,i){let o=this.spec.moteForce;e>=this.spec.moteRadius-this.spec.moteCollisionDecay&&(o=this.spec.moteForce*(this.spec.moteRadius-e)/this.spec.moteCollisionDecay),i=i.setMag(o),this.velocities[2*t]-=i.x,this.velocities[2*t+1]-=i.y,this.velocities[2*s]+=i.x,this.velocities[2*s+1]+=i.y,this.motes[4*t+2]++,this.motes[4*s+2]++}}self.onmessage=function(s){let{type:e,data:i}=s.data;if("init"===e){let{spec:s,seed:e,xDim:o,yDim:h}=i;t=new r(s,e,o,h)}else if("step"===e){let s=t.step(),e=t.motes.slice().buffer,i=t.clusters.map(t=>t.toJSON());self.postMessage({type:"update",motes:e,stepCounter:s,clusters:i},[e])}}})();
//# sourceMappingURL=moteSimulationWorker.85c05332.js.map
