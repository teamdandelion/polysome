{"mappings":"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","sources":["<anon>","src/moteSimulationWorker.ts","src/moteSimulator.ts","src/flowField.ts","src/safeMath.ts","src/vector.ts","src/safeRandom.ts","src/randomSeed.ts"],"sourcesContent":["(() => {\nvar $11e94a6f2f3cd93d$exports = {};\n/// <reference lib=\"webworker\" />\n// Helpful math functions, adapted from safeMath.js in qql-art/frontend\nfunction $4c550ce18ec8f877$export$18c7bea995a110f(v) {\n    return Math.PI * v;\n}\nfunction $4c550ce18ec8f877$export$842a2cf37af977e1(n, m) {\n    return (n % m + m) % m;\n}\nfunction $4c550ce18ec8f877$export$51a0620f7a28532b(value, step) {\n    return Math.round(value / step) * step;\n}\nfunction $4c550ce18ec8f877$export$e0b576e7a74416cd(value, min = null, max = null) {\n    value = max !== null ? Math.min(value, max) : value;\n    value = min !== null ? Math.max(value, min) : value;\n    return value;\n}\nfunction $4c550ce18ec8f877$export$bd2782c820638828(value, oldMin, oldMax, newMin, newMax) {\n    const clipped = $4c550ce18ec8f877$export$e0b576e7a74416cd(value, oldMin, oldMax);\n    const oldSpread = oldMax - oldMin;\n    const newSpread = newMax - newMin;\n    return newMin + (clipped - oldMin) * (newSpread / oldSpread);\n}\nfunction $4c550ce18ec8f877$export$1da80b13a4f0c868(start, end, t) {\n    return start + (end - start) * t;\n}\nfunction $4c550ce18ec8f877$export$cc6710ee5f037d57(...args) {\n    return args.reduce((lhs, rhs)=>lhs + rhs, 0) / args.length;\n}\nfunction $4c550ce18ec8f877$export$eba8049fb5020b81(value, maxIterations = 1000, epsilon = 1e-14, target = 1e-7) {\n    if (value < 0) throw new Error(\"Value must be non-negative.\");\n    let guess = value;\n    for(let index = 0; index < maxIterations; index++){\n        const error = guess * guess - value;\n        if (Math.abs(error) <= target) return guess;\n        const divisor = 2 * guess;\n        if (divisor <= epsilon) return guess;\n        guess -= error / divisor;\n    }\n    return guess;\n}\nfunction $4c550ce18ec8f877$export$6c4a311cc157c764(x1, y1, x2, y2) {\n    const dx = x1 - x2;\n    const dy = y1 - y2;\n    return $4c550ce18ec8f877$export$eba8049fb5020b81(dx * dx + dy * dy);\n}\nfunction $4c550ce18ec8f877$export$b8b770ee6a0d9760(y, x) {\n    const ax = Math.abs(x);\n    const ay = Math.abs(y);\n    const mx = Math.max(ay, ax);\n    const mn = Math.min(ay, ax);\n    const a = mn / mx;\n    /* Minimax polynomial approximation to atan(a) on [0,1] */ const s = a * a;\n    const c = s * a;\n    const q = s * s;\n    let r = 0.024840285 * q + 0.18681418;\n    let t = -0.094097948 * q - 0.33213072;\n    r = r * s + t;\n    r = r * c + a;\n    /* Map to full circle */ if (ay > ax) r = 1.57079637 - r;\n    if (x < 0) r = 3.14159274 - r;\n    if (y < 0) r = -r;\n    return r;\n}\n// Build an interpolation-based lookup function from a given table.\n// The function is assumed period, so given values outside the range will wrap.\nfunction $4c550ce18ec8f877$var$buildInterpolator(table, min, max) {\n    return (value)=>{\n        // Coerce value to [min, max) assuming periodicity.\n        value = $4c550ce18ec8f877$export$842a2cf37af977e1(value - min, max - min) + min;\n        const rescaled = $4c550ce18ec8f877$export$bd2782c820638828(value, min, max, 0, table.length - 1);\n        const index = Math.floor(rescaled); // This is within [0, table.length - 1).\n        const fraction = rescaled - index; // This is within [0, 1).\n        // Function evaluated at value is within [start, end) based on index.\n        const start = table[index];\n        const end = table[index + 1];\n        // Interpolate within [start, end) using fractional part.\n        return $4c550ce18ec8f877$export$1da80b13a4f0c868(start, end, fraction);\n    };\n}\nconst $4c550ce18ec8f877$var$cosTable = [\n    1.0,\n    0.99179,\n    0.96729,\n    0.92692,\n    0.87132,\n    0.80141,\n    0.71835,\n    0.62349,\n    0.51839,\n    0.40478,\n    0.28453,\n    0.1596,\n    0.03205,\n    -0.09602,\n    -0.22252,\n    -0.34537,\n    -0.46254,\n    -0.57212,\n    -0.6723,\n    -0.76145,\n    -0.83809,\n    -0.90097,\n    -0.94906,\n    -0.98156,\n    -0.99795,\n    -0.99795,\n    -0.98156,\n    -0.94906,\n    -0.90097,\n    -0.83809,\n    -0.76145,\n    -0.6723,\n    -0.57212,\n    -0.46254,\n    -0.34537,\n    -0.22252,\n    -0.09602,\n    0.03205,\n    0.1596,\n    0.28453,\n    0.40478,\n    0.51839,\n    0.62349,\n    0.71835,\n    0.80141,\n    0.87132,\n    0.92692,\n    0.96729,\n    0.99179,\n    1.0\n];\nconst $4c550ce18ec8f877$export$50d414a77b60d802 = $4c550ce18ec8f877$var$buildInterpolator($4c550ce18ec8f877$var$cosTable, 0, 2 * Math.PI);\nconst $4c550ce18ec8f877$var$sinTable = [\n    0.0,\n    0.12788,\n    0.25365,\n    0.37527,\n    0.49072,\n    0.59811,\n    0.69568,\n    0.78183,\n    0.85514,\n    0.91441,\n    0.95867,\n    0.98718,\n    0.99949,\n    0.99538,\n    0.97493,\n    0.93847,\n    0.8866,\n    0.82017,\n    0.74028,\n    0.64823,\n    0.54553,\n    0.43388,\n    0.31511,\n    0.19116,\n    0.06407,\n    -0.06407,\n    -0.19116,\n    -0.31511,\n    -0.43388,\n    -0.54553,\n    -0.64823,\n    -0.74028,\n    -0.82017,\n    -0.8866,\n    -0.93847,\n    -0.97493,\n    -0.99538,\n    -0.99949,\n    -0.98718,\n    -0.95867,\n    -0.91441,\n    -0.85514,\n    -0.78183,\n    -0.69568,\n    -0.59811,\n    -0.49072,\n    -0.37527,\n    -0.25365,\n    -0.12788,\n    -0\n];\nconst $4c550ce18ec8f877$export$5de3937cb4b592ed = $4c550ce18ec8f877$var$buildInterpolator($4c550ce18ec8f877$var$sinTable, 0, 2 * Math.PI);\nfunction $4c550ce18ec8f877$export$944b09d2ad10b378(x1, y1, x2, y2) {\n    const a = $4c550ce18ec8f877$export$b8b770ee6a0d9760(y2 - y1, x2 - x1);\n    return $4c550ce18ec8f877$export$842a2cf37af977e1(a, $4c550ce18ec8f877$export$18c7bea995a110f(2.0));\n}\nfunction $4c550ce18ec8f877$export$d6d6f3cc49a6d900(x1, y1, x2, y2) {\n    const dx = Math.abs(x1 - x2);\n    const dy = Math.abs(y1 - y2);\n    const min = Math.min(dx, dy);\n    const max = Math.max(dx, dy);\n    const alpha = 1007 / 1110;\n    const beta = 441 / 1110;\n    return alpha * max + beta * min;\n}\nfunction $4c550ce18ec8f877$export$2d1a743c6fb30728(x1, y1, x2, y2) {\n    const dx = Math.abs(x1 - x2);\n    const dy = Math.abs(y1 - y2);\n    const min = Math.min(dx, dy);\n    const max = Math.max(dx, dy);\n    const beta = 441 / 1024;\n    return max + beta * min;\n}\nfunction $4c550ce18ec8f877$export$4db2b6380409b372(x, y, theta, magnitude) {\n    return [\n        x + magnitude * $4c550ce18ec8f877$export$50d414a77b60d802(theta),\n        y + magnitude * $4c550ce18ec8f877$export$5de3937cb4b592ed(theta)\n    ];\n}\n\n\nclass $03e8730a80c32c61$export$9b781de7bf37bf48 {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    add(v) {\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(this.x + v.x, this.y + v.y);\n    }\n    sub(v) {\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(this.x - v.x, this.y - v.y);\n    }\n    mult(scalar) {\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(this.x * scalar, this.y * scalar);\n    }\n    angle() {\n        return Math.atan2(this.y, this.x);\n    }\n    setMag(magnitude) {\n        const angle = this.angle();\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\n    }\n    static fromAngle(angle) {\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(Math.cos(angle), Math.sin(angle));\n    }\n    static dist(v1, v2) {\n        return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2);\n    }\n    // Serialize the Vector to a plain object\n    toJSON() {\n        return {\n            x: this.x,\n            y: this.y\n        };\n    }\n    // Deserialize a plain object to a Vector\n    static fromJSON(json) {\n        return new $03e8730a80c32c61$export$9b781de7bf37bf48(json.x, json.y);\n    }\n}\n\n\nfunction $1aa6a5cda7d913a4$export$15b688b761fa49c2(r, spec, bounds) {\n    const { numDisturbances: numDisturbances, thetaVariance: thetaVariance, defaultTheta: defaultTheta } = spec;\n    const disturbances = [];\n    for(let i = 0; i < numDisturbances; i++){\n        const disturbanceX = r.uniform(0, bounds.x);\n        const disturbanceY = r.uniform(0, bounds.y);\n        const disturbanceTheta = r.gauss(0, thetaVariance);\n        const disturbanceRadius = Math.abs(r.gauss(spec.disturbanceRadiusMean, spec.disturbanceRadiusVariance));\n        disturbances.push({\n            pos: new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(disturbanceX, disturbanceY),\n            theta: disturbanceTheta,\n            radius: disturbanceRadius\n        });\n    }\n    return {\n        defaultTheta: defaultTheta,\n        disturbances: disturbances,\n        bounds: bounds\n    };\n}\nclass $1aa6a5cda7d913a4$export$b28d348bb9299663 {\n    constructor(spec){\n        this.spacing = 4;\n        const iMax = Math.ceil(spec.bounds.x / this.spacing);\n        const jMax = Math.ceil(spec.bounds.y / this.spacing);\n        this.fieldPoints = Array.from({\n            length: iMax\n        }, ()=>new Float64Array(jMax).fill(spec.defaultTheta));\n        for (const { pos: pos, theta: theta, radius: radius } of spec.disturbances){\n            const minX = pos.x - radius;\n            const maxX = pos.x + radius;\n            const minY = pos.y - radius;\n            const maxY = pos.y + radius;\n            const minI = Math.max(0, Math.floor(minX / this.spacing));\n            const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n            const minJ = Math.max(0, Math.floor(minY / this.spacing));\n            const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n            for(let i = minI; i < maxI; i++){\n                const x = this.spacing * i;\n                for(let j = minJ; j < maxJ; j++){\n                    const y = this.spacing * j;\n                    const d = (0, $4c550ce18ec8f877$export$6c4a311cc157c764)(pos.x, pos.y, x, y);\n                    const thetaAdjust = (0, $4c550ce18ec8f877$export$bd2782c820638828)(d, 0, radius, theta, 0);\n                    this.fieldPoints[i][j] += thetaAdjust;\n                }\n            }\n        }\n    }\n    flow(pos) {\n        const i = Math.floor(pos.x / this.spacing);\n        const j = Math.floor(pos.y / this.spacing);\n        const theta = this.fieldPoints[i][j];\n        return (0, $03e8730a80c32c61$export$9b781de7bf37bf48).fromAngle(theta);\n    }\n}\nclass $1aa6a5cda7d913a4$export$6277d9167271f79d {\n    constructor(rng, bounds){\n        this.spacing = 4;\n        this.numDisturbances = 30;\n        this.thetaVariance = 3.14;\n        this.disturbanceRadiusMean = 100;\n        this.disturbanceRadiusVariance = 200;\n        this.disturbances = [];\n        this.rng = rng;\n        this.bounds = bounds;\n        this.defaultTheta = rng.uniform(0, (0, $4c550ce18ec8f877$export$18c7bea995a110f)(2));\n        this.fieldPoints = [];\n        this.disturbances = [];\n        while(this.disturbances.length < this.numDisturbances)this.addDisturbance();\n        this.computeFlowField();\n    }\n    inBounds(pos) {\n        return pos.x >= 0 && pos.x <= this.bounds.x && pos.y >= 0 && pos.y <= this.bounds.y;\n    }\n    addDisturbance() {\n        const disturbanceX = this.rng.uniform(0, this.bounds.x);\n        const disturbanceY = this.rng.uniform(0, this.bounds.y);\n        const disturbanceTheta = this.rng.gauss(0, this.thetaVariance);\n        const disturbanceRadius = Math.abs(this.rng.gauss(this.disturbanceRadiusMean, this.disturbanceRadiusVariance));\n        const disturbanceHeading = this.rng.uniform(0, (0, $4c550ce18ec8f877$export$18c7bea995a110f)(2));\n        const disturbanceSpeed = this.rng.uniform(0, 0.5);\n        const disturbanceVel = (0, $03e8730a80c32c61$export$9b781de7bf37bf48).fromAngle(disturbanceHeading).mult(disturbanceSpeed);\n        this.disturbances.push({\n            pos: new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(disturbanceX, disturbanceY),\n            vel: disturbanceVel,\n            theta: disturbanceTheta,\n            radius: disturbanceRadius\n        });\n    }\n    computeFlowField() {\n        const iMax = Math.ceil(this.bounds.x / this.spacing);\n        const jMax = Math.ceil(this.bounds.y / this.spacing);\n        this.fieldPoints = Array.from({\n            length: iMax\n        }, ()=>new Float64Array(jMax).fill(this.defaultTheta));\n        for (const { pos: pos, theta: theta, radius: radius } of this.disturbances){\n            const minX = pos.x - radius;\n            const maxX = pos.x + radius;\n            const minY = pos.y - radius;\n            const maxY = pos.y + radius;\n            const minI = Math.max(0, Math.floor(minX / this.spacing));\n            const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n            const minJ = Math.max(0, Math.floor(minY / this.spacing));\n            const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n            for(let i = minI; i < maxI; i++){\n                const x = this.spacing * i;\n                for(let j = minJ; j < maxJ; j++){\n                    const y = this.spacing * j;\n                    const dx = pos.x - x;\n                    const dy = pos.y - y;\n                    const d = Math.sqrt(dx * dx + dy * dy);\n                    const thetaAdjust = d <= radius ? theta * (1 - d / radius) : 0;\n                    this.fieldPoints[i][j] += thetaAdjust;\n                }\n            }\n        }\n    }\n    step() {\n        for (const disturbance of this.disturbances){\n            disturbance.pos.add(disturbance.vel);\n            if (!this.inBounds(disturbance.pos)) disturbance.vel.mult(-1);\n        }\n        this.computeFlowField();\n    }\n    flow(pos) {\n        const i = Math.floor(pos.x / this.spacing);\n        const j = Math.floor(pos.y / this.spacing);\n        const theta = this.fieldPoints[i][j];\n        return (0, $03e8730a80c32c61$export$9b781de7bf37bf48).fromAngle(theta);\n    }\n}\n\n\n// picks a uniformly random `bytes32` using JS Math.random state\n// (i.e., not itself seeded by `safe-random.js`)\nfunction $ed2c1f798b210124$export$2e2bcd8739ae039() {\n    let nibbles = Array(64).fill(0).map(()=>Math.floor(Math.random() * 16).toString(16));\n    return \"0x\" + nibbles.join(\"\");\n}\n\n\n// Note that the index order [0, 1, 2, 3] is little-endian\nconst $ba609055bbdbfded$var$eps = Math.pow(2, -32), $ba609055bbdbfded$var$m0 = 0x7f2d, $ba609055bbdbfded$var$m1 = 0x4c95, $ba609055bbdbfded$var$m2 = 0xf42d, $ba609055bbdbfded$var$m3 = 0x5851, $ba609055bbdbfded$var$a0 = 0x814f, $ba609055bbdbfded$var$a1 = 0xf767, $ba609055bbdbfded$var$a2 = 0x7b7e, $ba609055bbdbfded$var$a3 = 0x1405; // 1442695040888963407\nfunction $ba609055bbdbfded$export$7c1be48efc5e4b3b(hash /*: bytes32 */ ) /*: Rng */ {\n    const rng = new $ba609055bbdbfded$export$b15cd8f5723f9e05();\n    rng.setSeed(hash);\n    return rng;\n}\nfunction $ba609055bbdbfded$export$49af3cf86fe080fb() /*: Rng */ {\n    return $ba609055bbdbfded$export$7c1be48efc5e4b3b((0, $ed2c1f798b210124$export$2e2bcd8739ae039)());\n}\nclass $ba609055bbdbfded$export$b15cd8f5723f9e05 {\n    constructor(){\n        this._state = new Uint16Array(4);\n        this._dv = new DataView(this._state.buffer);\n        this._nG = null; // nextGaussian\n        this._hNG = false; // hasNextGaussian\n    }\n    // sets the seed to a tokenData hash string \"0x...\"\n    setSeed(hash) {\n        this._hNG = false;\n        this._nG = null;\n        const nBytes = ~~((hash.length - 2) / 2);\n        const bytes = [];\n        for(let j = 0; j < nBytes; j++){\n            const e0 = 2 + 2 * j;\n            bytes.push(parseInt(hash.slice(e0, e0 + 2), 16));\n        }\n        // to keep it simple, we just use 32bit murmur2 with two different seeds\n        const seed_a = 1690382925;\n        const seed_b = 72970470;\n        const lower = $ba609055bbdbfded$var$hash32(bytes, seed_a);\n        const upper = $ba609055bbdbfded$var$hash32(bytes, seed_b);\n        this._dv.setUint32(0, lower);\n        this._dv.setUint32(4, upper);\n    }\n    // random value between 0..1\n    rnd() {\n        const state = this._state;\n        // Advance internal state\n        const s0 = state[0], s1 = state[1], s2 = state[2], s3 = state[3], new0 = $ba609055bbdbfded$var$a0 + $ba609055bbdbfded$var$m0 * s0 | 0, new1 = $ba609055bbdbfded$var$a1 + $ba609055bbdbfded$var$m0 * s1 + ($ba609055bbdbfded$var$m1 * s0 + (new0 >>> 16)) | 0, new2 = $ba609055bbdbfded$var$a2 + $ba609055bbdbfded$var$m0 * s2 + $ba609055bbdbfded$var$m1 * s1 + ($ba609055bbdbfded$var$m2 * s0 + (new1 >>> 16)) | 0, new3 = $ba609055bbdbfded$var$a3 + $ba609055bbdbfded$var$m0 * s3 + ($ba609055bbdbfded$var$m1 * s2 + $ba609055bbdbfded$var$m2 * s1) + ($ba609055bbdbfded$var$m3 * s0 + (new2 >>> 16));\n        state[0] = new0, state[1] = new1, state[2] = new2;\n        state[3] = new3;\n        // Calculate output function (XSH RR), uses old state\n        const xorshifted = (s3 << 21) + ((s3 >> 2 ^ s2) << 5) + ((s2 >> 2 ^ s1) >> 11), out_int32 = xorshifted >>> (s3 >> 11) | xorshifted << (-(s3 >> 11) & 31);\n        return $ba609055bbdbfded$var$eps * (out_int32 >>> 0);\n    }\n    // random value between min (inclusive) and max (exclusive)\n    uniform(min = 1, max = null) {\n        if (max === null) [min, max] = [\n            0,\n            min\n        ];\n        return this.rnd() * (max - min) + min;\n    }\n    // random gaussian distribution\n    gauss(mean = 0, variance = 1) {\n        // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/Random.java#L496\n        if (this._hNG) {\n            this._hNG = false;\n            var result = this._nG;\n            this._nG = null;\n            return mean + variance * result;\n        } else {\n            var v1 = 0;\n            var v2 = 0;\n            var s = 0;\n            do {\n                v1 = this.rnd() * 2 - 1; // between -1 and 1\n                v2 = this.rnd() * 2 - 1; // between -1 and 1\n                s = v1 * v1 + v2 * v2;\n            }while (s >= 1 || s === 0);\n            var multiplier = Math.sqrt(-2 * Math.log(s) / s);\n            this._nG = v2 * multiplier;\n            this._hNG = true;\n            return mean + variance * (v1 * multiplier);\n        }\n    }\n    odds(p) {\n        return this.uniform() <= p;\n    }\n    choice(items) {\n        return items[Math.floor(this.uniform(0, items.length))];\n    }\n    weightedChoice(items) {\n        const sumWeight = items.map(([, weight])=>weight).reduce((lhs, rhs)=>lhs + rhs, 0);\n        const bisection = sumWeight * this.uniform();\n        let cumWeight = 0;\n        for(let index = 0; index < items.length; index++){\n            const [value, weight] = items[index];\n            cumWeight += weight;\n            if (cumWeight >= bisection) return value;\n        }\n        const [lastValue] = items[items.length - 1];\n        return lastValue;\n    }\n    // alias for weightedChoice\n    wc(items) {\n        return this.weightedChoice(items);\n    }\n    // a version of shuffle that safely uses our PRNG\n    shuffle(items) {\n        const joined = items.map((item)=>[\n                this.uniform(0.0, 1.0),\n                item\n            ]);\n        joined.sort((a, b)=>{\n            return a[0] < b[0] ? -1 : 1;\n        });\n        return joined.map(([, item])=>item);\n    }\n    // returns a copy of the array that has been \"winnowed\" down to contain at most `num`\n    // entries, while preserving the original order\n    winnow(input, num) {\n        const items = input.slice();\n        while(items.length > num){\n            const index = Math.floor(this.rnd() * items.length);\n            items.splice(index, 1);\n        }\n        return items;\n    }\n}\n// internally gets a 32-bit from tokenData hash bytes\nfunction $ba609055bbdbfded$var$hash32(bytes, seed = 0) {\n    // murmur2 32bit\n    // https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\n    const K = 16;\n    const mask = 65535;\n    const maskByte = 0xff;\n    var m = 0x5bd1e995;\n    var l = bytes.length, h = seed ^ l, i = 0, k;\n    while(l >= 4){\n        k = bytes[i] & maskByte | (bytes[++i] & maskByte) << 8 | (bytes[++i] & maskByte) << 16 | (bytes[++i] & maskByte) << 24;\n        k = (k & mask) * m + (((k >>> K) * m & mask) << K);\n        k ^= k >>> 24;\n        k = (k & mask) * m + (((k >>> K) * m & mask) << K);\n        h = (h & mask) * m + (((h >>> K) * m & mask) << K) ^ k;\n        l -= 4;\n        ++i;\n    }\n    /* eslint-disable no-fallthrough */ switch(l){\n        case 3:\n            h ^= (bytes[i + 2] & maskByte) << K;\n        case 2:\n            h ^= (bytes[i + 1] & maskByte) << 8;\n        case 1:\n            h ^= bytes[i] & maskByte;\n            h = (h & mask) * m + (((h >>> K) * m & mask) << K);\n    }\n    /* eslint-enable no-fallthrough */ h ^= h >>> 13;\n    h = (h & mask) * m + (((h >>> K) * m & mask) << K);\n    h ^= h >>> 15;\n    return h >>> 0;\n}\n\n\n\nclass $8c085251956c254b$export$57ed47926628b770 {\n    constructor(initialMote, initialPosition){\n        this.position = initialPosition;\n        this.motes = new Set([\n            initialMote\n        ]);\n    }\n    update(motes) {\n        let sum = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(0, 0);\n        for (const moteIndex of this.motes)sum = sum.add(new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(motes[moteIndex * 4], motes[moteIndex * 4 + 1]));\n        this.position = sum.mult(1 / this.motes.size);\n    }\n    toJSON() {\n        return {\n            position: this.position.toJSON(),\n            motes: Array.from(this.motes)\n        };\n    }\n    static fromJSON(json) {\n        const cluster = new $8c085251956c254b$export$57ed47926628b770(-1, (0, $03e8730a80c32c61$export$9b781de7bf37bf48).fromJSON(json.position));\n        cluster.motes = new Set(json.motes);\n        return cluster;\n    }\n}\nclass $8c085251956c254b$export$4cd0859bc913b350 {\n    constructor(spec, seed, xDim, yDim){\n        this.clusters = [];\n        this.stepCounter = 0;\n        this.spec = spec;\n        this.xMax = xDim;\n        this.yMax = yDim;\n        this.rng = (0, $ba609055bbdbfded$export$7c1be48efc5e4b3b)(seed);\n        this.flowField = new (0, $1aa6a5cda7d913a4$export$6277d9167271f79d)(this.rng, new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(xDim, yDim));\n        this.nMotes = spec.numMotes;\n        this.motes = new Float32Array(this.nMotes * 4); // x, y, nCollisions, stepAdded\n        this.velocities = new Float32Array(this.nMotes * 2); // vx, vy\n        // Initialize mote positions randomly\n        for(let i = 0; i < this.nMotes; i++){\n            this.motes[i * 4] = this.rng.uniform(0, this.xMax);\n            this.motes[i * 4 + 1] = this.rng.uniform(0, this.yMax);\n            this.motes[i * 4 + 2] = 0; // Initialize collision count to 0\n            this.motes[i * 4 + 3] = 0; // Initialize step-added-on to 0\n        }\n        this.start = Date.now();\n    }\n    step() {\n        this.flowField.step(); // Update the flow field\n        this.reset(); // Reset mote colllision velocities and collision counts\n        this.processCollisions(); // Compute collision velocity and count for each mote\n        this.updateClusters(); // Update mote clusters\n        this.applyClusterDynamics(); // Apply cluster dynamics\n        this.moveMotes(); // Move motes based on collision velocities and flow field\n        return this.stepCounter++;\n    }\n    reset() {\n        for(let i = 0; i < this.nMotes; i++){\n            // Check if the mote is out of bounds\n            if (this.motes[i * 4] < 0 || this.motes[i * 4] >= this.xMax || this.motes[i * 4 + 1] < 0 || this.motes[i * 4 + 1] >= this.yMax) {\n                // Assign a random position in-bounds\n                this.motes[i * 4] = this.rng.uniform(0, this.xMax);\n                this.motes[i * 4 + 1] = this.rng.uniform(0, this.yMax);\n                this.motes[i * 4 + 3] = this.stepCounter;\n            }\n            this.motes[i * 4 + 2] = 0; // Reset collision count\n            this.velocities[i * 2] = 0; // Reset x velocity\n            this.velocities[i * 2 + 1] = 0; // Reset y velocity\n        }\n    }\n    processCollisions() {\n        const gridSize = this.spec.moteRadius * 2;\n        const grid = new Map();\n        const radiusSq = this.spec.moteRadius * this.spec.moteRadius;\n        let motesInClusters = new Set(this.clusters.flatMap((cluster)=>Array.from(cluster.motes)));\n        // Create a map for quick cluster lookup\n        const clusterMap = new Map();\n        this.clusters.forEach((cluster)=>cluster.motes.forEach((mote)=>clusterMap.set(mote, cluster)));\n        // Populate the grid\n        for(let i = 0; i < this.nMotes; i++){\n            const x = Math.floor(this.motes[i * 4] / gridSize);\n            const y = Math.floor(this.motes[i * 4 + 1] / gridSize);\n            const key = `${x},${y}`;\n            if (!grid.has(key)) grid.set(key, []);\n            grid.get(key).push(i);\n        }\n        // Check for collisions\n        for (let [key, motesInCell] of grid.entries()){\n            const [x, y] = key.split(\",\").map(Number);\n            const neighbors = [\n                `${x},${y}`,\n                `${x + 1},${y}`,\n                `${x - 1},${y}`,\n                `${x},${y + 1}`,\n                `${x},${y - 1}`,\n                `${x + 1},${y + 1}`,\n                `${x - 1},${y - 1}`,\n                `${x + 1},${y - 1}`,\n                `${x - 1},${y + 1}`\n            ];\n            for (let neighborKey of neighbors){\n                const neighborMotes = grid.get(neighborKey);\n                if (neighborMotes) for (let i of motesInCell){\n                    let potentialCluster = clusterMap.get(i) ?? new $8c085251956c254b$export$57ed47926628b770(i, new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.motes[i * 4], this.motes[i * 4 + 1]));\n                    let isNewCluster = !clusterMap.has(i);\n                    for (let j of neighborMotes)if (i < j) {\n                        const jx = this.motes[j * 4];\n                        const jy = this.motes[j * 4 + 1];\n                        const dx = this.motes[j * 4] - this.motes[i * 4];\n                        const dy = this.motes[j * 4 + 1] - this.motes[i * 4 + 1];\n                        const dsq = dx * dx + dy * dy;\n                        const cdx = potentialCluster.position.x - jx;\n                        const cdy = potentialCluster.position.y - jy;\n                        const cdSq = cdx * cdx + cdy * cdy;\n                        if (dsq < radiusSq) {\n                            const v = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(dx, dy);\n                            const d = Math.sqrt(dsq);\n                            this.collide(i, j, d, v);\n                        }\n                        if (cdSq < this.spec.clusterRadius * this.spec.clusterRadius) {\n                            potentialCluster.motes.add(j);\n                            if (!isNewCluster) clusterMap.set(j, potentialCluster);\n                        }\n                    }\n                    if (isNewCluster && potentialCluster.motes.size > this.spec.clusterSize) {\n                        this.clusters.push(potentialCluster);\n                        for (let mote of potentialCluster.motes)clusterMap.set(mote, potentialCluster);\n                    }\n                }\n            }\n        }\n    }\n    moveMotes() {\n        for(let i = 0; i < this.nMotes; i++){\n            // Compute the flow field vector for the mote\n            let flowVector = this.flowField.flow(new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.motes[i * 4], this.motes[i * 4 + 1]));\n            // Scale the magnitude of the flow field vector\n            const nCollisions = this.motes[i * 4 + 2];\n            const flowCoefficient = Math.pow(this.spec.cxFlowCoefficient, nCollisions);\n            flowVector = flowVector.mult(this.spec.flowCoefficient * flowCoefficient);\n            // Update the mote position based on the flow field vector and the aggregate collision vector\n            this.motes[i * 4] += flowVector.x + this.velocities[i * 2];\n            this.motes[i * 4 + 1] += flowVector.y + this.velocities[i * 2 + 1];\n        }\n    }\n    updateClusters() {\n        const clustersToRemove = new Set();\n        // Update existing clusters\n        for(let i = this.clusters.length - 1; i >= 0; i--){\n            const cluster = this.clusters[i];\n            cluster.update(this.motes);\n            // Remove motes that are too far from the new cluster center\n            for (const moteIndex of cluster.motes){\n                const motePos = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.motes[moteIndex * 4], this.motes[moteIndex * 4 + 1]);\n                if ((0, $03e8730a80c32c61$export$9b781de7bf37bf48).dist(cluster.position, motePos) > this.spec.clusterRadius) cluster.motes.delete(moteIndex);\n            }\n            // Mark clusters that are too small for removal\n            if (cluster.motes.size < this.spec.clusterCollapseSize) clustersToRemove.add(i);\n        }\n        // Merge clusters\n        for(let i = this.clusters.length - 1; i >= 0; i--){\n            if (clustersToRemove.has(i)) continue;\n            const cluster = this.clusters[i];\n            for(let j = i - 1; j >= 0; j--){\n                if (clustersToRemove.has(j)) continue;\n                const otherCluster = this.clusters[j];\n                if ((0, $03e8730a80c32c61$export$9b781de7bf37bf48).dist(cluster.position, otherCluster.position) < this.spec.clusterRadius) {\n                    cluster.motes = new Set([\n                        ...cluster.motes,\n                        ...otherCluster.motes\n                    ]);\n                    cluster.update(this.motes); // Update position after merging\n                    clustersToRemove.add(j);\n                }\n            }\n        }\n        // Remove marked clusters\n        for(let i = this.clusters.length - 1; i >= 0; i--)if (clustersToRemove.has(i)) this.clusters.splice(i, 1);\n    }\n    applyClusterDynamics() {\n        for (const cluster of this.clusters)for (const moteIndex of cluster.motes){\n            const motePos = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.motes[moteIndex * 4], this.motes[moteIndex * 4 + 1]);\n            const distanceToCenter = (0, $03e8730a80c32c61$export$9b781de7bf37bf48).dist(motePos, cluster.position);\n            // Apply cohesion force\n            let cohesionForce = cluster.position.sub(motePos);\n            const cohesionStrength = Math.min(distanceToCenter * this.spec.clusterCohesionFactor, this.spec.maxCohesionForce);\n            cohesionForce = cohesionForce.setMag(cohesionStrength);\n            // Apply separation force\n            let separationForce = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(0, 0);\n            if (distanceToCenter < this.spec.clusterSeparationRadius) {\n                separationForce = motePos.sub(cluster.position);\n                const separationStrength = this.spec.clusterSeparationFactor * (1 - distanceToCenter / this.spec.clusterSeparationRadius);\n                separationForce = separationForce.setMag(separationStrength);\n            }\n            // Apply alignment force (assuming we have a method to calculate cluster velocity)\n            const clusterVelocity = this.calculateClusterVelocity(cluster);\n            let alignmentForce = clusterVelocity.sub(new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.velocities[moteIndex * 2], this.velocities[moteIndex * 2 + 1]));\n            alignmentForce = alignmentForce.mult(this.spec.clusterAlignmentFactor);\n            // Combine forces\n            const totalForce = cohesionForce.add(separationForce).add(alignmentForce);\n            // Apply the combined force\n            this.velocities[moteIndex * 2] += totalForce.x;\n            this.velocities[moteIndex * 2 + 1] += totalForce.y;\n        }\n    }\n    calculateClusterVelocity(cluster) {\n        let avgVelocity = new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(0, 0);\n        for (const moteIndex of cluster.motes)avgVelocity = avgVelocity.add(new (0, $03e8730a80c32c61$export$9b781de7bf37bf48)(this.velocities[moteIndex * 2], this.velocities[moteIndex * 2 + 1]));\n        return avgVelocity.mult(1 / cluster.motes.size);\n    }\n    // Handle collisions\n    collide(a, b, d, v) {\n        let forceFactor = this.spec.moteForce;\n        if (d >= this.spec.moteRadius - this.spec.moteCollisionDecay) forceFactor = this.spec.moteForce * (this.spec.moteRadius - d) / this.spec.moteCollisionDecay;\n        v = v.setMag(forceFactor);\n        this.velocities[a * 2] -= v.x;\n        this.velocities[a * 2 + 1] -= v.y;\n        this.velocities[b * 2] += v.x;\n        this.velocities[b * 2 + 1] += v.y;\n        // Increment collision counts\n        this.motes[a * 4 + 2]++;\n        this.motes[b * 4 + 2]++;\n    }\n}\n\n\nlet $11e94a6f2f3cd93d$var$simulator;\nself.onmessage = function(e) {\n    const { type: type, data: data } = e.data;\n    if (type === \"init\") {\n        const { spec: spec, seed: seed, xDim: xDim, yDim: yDim } = data;\n        $11e94a6f2f3cd93d$var$simulator = new (0, $8c085251956c254b$export$4cd0859bc913b350)(spec, seed, xDim, yDim);\n    } else if (type === \"step\") {\n        const step = $11e94a6f2f3cd93d$var$simulator.step();\n        const motesBuffer = $11e94a6f2f3cd93d$var$simulator.motes.slice().buffer;\n        const clusters = $11e94a6f2f3cd93d$var$simulator.clusters.map((cluster)=>cluster.toJSON());\n        self.postMessage({\n            type: \"update\",\n            motes: motesBuffer,\n            stepCounter: step,\n            clusters: clusters\n        }, [\n            motesBuffer\n        ]);\n    }\n};\n\n})();\n//# sourceMappingURL=moteSimulationWorker.85c05332.js.map\n","/// <reference lib=\"webworker\" />\n\nimport { MoteSimulator } from \"./moteSimulator.js\";\n\nlet simulator: MoteSimulator;\n\nself.onmessage = function (e) {\n  const { type, data } = e.data;\n\n  if (type === \"init\") {\n    const { spec, seed, xDim, yDim } = data;\n    simulator = new MoteSimulator(spec, seed, xDim, yDim);\n  } else if (type === \"step\") {\n    const step = simulator.step();\n    const motesBuffer = simulator.motes.slice().buffer;\n    const clusters = simulator.clusters.map((cluster) => cluster.toJSON());\n    self.postMessage(\n      {\n        type: \"update\",\n        motes: motesBuffer,\n        stepCounter: step,\n        clusters,\n      },\n      [motesBuffer]\n    );\n  }\n};\n","import { DynamicFlowField } from \"./flowField.js\";\nimport { Rng, makeSeededRng } from \"./safeRandom.js\";\nimport { Spec } from \"./spec.js\";\nimport { Vector } from \"./vector.js\";\n\nclass Cluster {\n  public position: Vector;\n  public motes: Set<number>;\n\n  constructor(initialMote: number, initialPosition: Vector) {\n    this.position = initialPosition;\n    this.motes = new Set([initialMote]);\n  }\n\n  update(motes: Float32Array) {\n    let sum = new Vector(0, 0);\n    for (const moteIndex of this.motes) {\n      sum = sum.add(new Vector(motes[moteIndex * 4], motes[moteIndex * 4 + 1]));\n    }\n    this.position = sum.mult(1 / this.motes.size);\n  }\n\n  toJSON() {\n    return {\n      position: this.position.toJSON(),\n      motes: Array.from(this.motes),\n    };\n  }\n\n  static fromJSON(json: any) {\n    const cluster = new Cluster(-1, Vector.fromJSON(json.position));\n    cluster.motes = new Set(json.motes);\n    return cluster;\n  }\n}\n\nclass MoteSimulator {\n  private rng: Rng;\n  private xMax: number;\n  private yMax: number;\n\n  private nMotes: number;\n  public motes: Float32Array;\n  public clusters: Cluster[] = [];\n  private velocities: Float32Array;\n  private flowField: DynamicFlowField;\n  private spec: Spec;\n  private start: number;\n  public stepCounter = 0;\n\n  constructor(spec: Spec, seed: string, xDim: number, yDim: number) {\n    this.spec = spec;\n    this.xMax = xDim;\n    this.yMax = yDim;\n    this.rng = makeSeededRng(seed);\n    this.flowField = new DynamicFlowField(this.rng, new Vector(xDim, yDim));\n\n    this.nMotes = spec.numMotes;\n    this.motes = new Float32Array(this.nMotes * 4); // x, y, nCollisions, stepAdded\n    this.velocities = new Float32Array(this.nMotes * 2); // vx, vy\n\n    // Initialize mote positions randomly\n    for (let i = 0; i < this.nMotes; i++) {\n      this.motes[i * 4] = this.rng.uniform(0, this.xMax);\n      this.motes[i * 4 + 1] = this.rng.uniform(0, this.yMax);\n      this.motes[i * 4 + 2] = 0; // Initialize collision count to 0\n      this.motes[i * 4 + 3] = 0; // Initialize step-added-on to 0\n    }\n    this.start = Date.now();\n  }\n\n  step(): number {\n    this.flowField.step(); // Update the flow field\n    this.reset(); // Reset mote colllision velocities and collision counts\n    this.processCollisions(); // Compute collision velocity and count for each mote\n    this.updateClusters(); // Update mote clusters\n    this.applyClusterDynamics(); // Apply cluster dynamics\n    this.moveMotes(); // Move motes based on collision velocities and flow field\n    return this.stepCounter++;\n  }\n\n  reset(): void {\n    for (let i = 0; i < this.nMotes; i++) {\n      // Check if the mote is out of bounds\n      if (\n        this.motes[i * 4] < 0 ||\n        this.motes[i * 4] >= this.xMax ||\n        this.motes[i * 4 + 1] < 0 ||\n        this.motes[i * 4 + 1] >= this.yMax\n      ) {\n        // Assign a random position in-bounds\n        this.motes[i * 4] = this.rng.uniform(0, this.xMax);\n        this.motes[i * 4 + 1] = this.rng.uniform(0, this.yMax);\n        this.motes[i * 4 + 3] = this.stepCounter;\n      }\n      this.motes[i * 4 + 2] = 0; // Reset collision count\n      this.velocities[i * 2] = 0; // Reset x velocity\n      this.velocities[i * 2 + 1] = 0; // Reset y velocity\n    }\n  }\n\n  processCollisions(): void {\n    const gridSize = this.spec.moteRadius * 2;\n    const grid = new Map<string, number[]>();\n    const radiusSq = this.spec.moteRadius * this.spec.moteRadius;\n    let motesInClusters = new Set<number>(\n      this.clusters.flatMap((cluster) => Array.from(cluster.motes))\n    );\n\n    // Create a map for quick cluster lookup\n    const clusterMap = new Map<number, Cluster>();\n    this.clusters.forEach((cluster) =>\n      cluster.motes.forEach((mote) => clusterMap.set(mote, cluster))\n    );\n    // Populate the grid\n    for (let i = 0; i < this.nMotes; i++) {\n      const x = Math.floor(this.motes[i * 4] / gridSize);\n      const y = Math.floor(this.motes[i * 4 + 1] / gridSize);\n      const key = `${x},${y}`;\n      if (!grid.has(key)) {\n        grid.set(key, []);\n      }\n      grid.get(key)!.push(i);\n    }\n\n    // Check for collisions\n    for (let [key, motesInCell] of grid.entries()) {\n      const [x, y] = key.split(\",\").map(Number);\n      const neighbors = [\n        `${x},${y}`,\n        `${x + 1},${y}`,\n        `${x - 1},${y}`,\n        `${x},${y + 1}`,\n        `${x},${y - 1}`,\n        `${x + 1},${y + 1}`,\n        `${x - 1},${y - 1}`,\n        `${x + 1},${y - 1}`,\n        `${x - 1},${y + 1}`,\n      ];\n\n      for (let neighborKey of neighbors) {\n        const neighborMotes = grid.get(neighborKey);\n        if (neighborMotes) {\n          for (let i of motesInCell) {\n            let potentialCluster =\n              clusterMap.get(i) ??\n              new Cluster(\n                i,\n                new Vector(this.motes[i * 4], this.motes[i * 4 + 1])\n              );\n            let isNewCluster = !clusterMap.has(i);\n\n            for (let j of neighborMotes) {\n              if (i < j) {\n                const jx = this.motes[j * 4];\n                const jy = this.motes[j * 4 + 1];\n                const dx = this.motes[j * 4] - this.motes[i * 4];\n                const dy = this.motes[j * 4 + 1] - this.motes[i * 4 + 1];\n                const dsq = dx * dx + dy * dy;\n\n                const cdx = potentialCluster.position.x - jx;\n                const cdy = potentialCluster.position.y - jy;\n                const cdSq = cdx * cdx + cdy * cdy;\n\n                if (dsq < radiusSq) {\n                  const v = new Vector(dx, dy);\n                  const d = Math.sqrt(dsq);\n                  this.collide(i, j, d, v);\n                }\n                if (cdSq < this.spec.clusterRadius * this.spec.clusterRadius) {\n                  potentialCluster.motes.add(j);\n                  if (!isNewCluster) {\n                    clusterMap.set(j, potentialCluster);\n                  }\n                }\n              }\n            }\n            if (\n              isNewCluster &&\n              potentialCluster.motes.size > this.spec.clusterSize\n            ) {\n              this.clusters.push(potentialCluster);\n              for (let mote of potentialCluster.motes) {\n                clusterMap.set(mote, potentialCluster);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  moveMotes() {\n    for (let i = 0; i < this.nMotes; i++) {\n      // Compute the flow field vector for the mote\n      let flowVector = this.flowField.flow(\n        new Vector(this.motes[i * 4], this.motes[i * 4 + 1])\n      );\n\n      // Scale the magnitude of the flow field vector\n      const nCollisions = this.motes[i * 4 + 2];\n      const flowCoefficient = Math.pow(\n        this.spec.cxFlowCoefficient,\n        nCollisions\n      );\n      flowVector = flowVector.mult(this.spec.flowCoefficient * flowCoefficient);\n\n      // Update the mote position based on the flow field vector and the aggregate collision vector\n      this.motes[i * 4] += flowVector.x + this.velocities[i * 2];\n      this.motes[i * 4 + 1] += flowVector.y + this.velocities[i * 2 + 1];\n    }\n  }\n\n  updateClusters(): void {\n    const clustersToRemove = new Set<number>();\n\n    // Update existing clusters\n    for (let i = this.clusters.length - 1; i >= 0; i--) {\n      const cluster = this.clusters[i];\n      cluster.update(this.motes);\n\n      // Remove motes that are too far from the new cluster center\n      for (const moteIndex of cluster.motes) {\n        const motePos = new Vector(\n          this.motes[moteIndex * 4],\n          this.motes[moteIndex * 4 + 1]\n        );\n        if (Vector.dist(cluster.position, motePos) > this.spec.clusterRadius) {\n          cluster.motes.delete(moteIndex);\n        }\n      }\n\n      // Mark clusters that are too small for removal\n      if (cluster.motes.size < this.spec.clusterCollapseSize) {\n        clustersToRemove.add(i);\n      }\n    }\n\n    // Merge clusters\n    for (let i = this.clusters.length - 1; i >= 0; i--) {\n      if (clustersToRemove.has(i)) continue;\n      const cluster = this.clusters[i];\n      for (let j = i - 1; j >= 0; j--) {\n        if (clustersToRemove.has(j)) continue;\n        const otherCluster = this.clusters[j];\n        if (\n          Vector.dist(cluster.position, otherCluster.position) <\n          this.spec.clusterRadius\n        ) {\n          cluster.motes = new Set([...cluster.motes, ...otherCluster.motes]);\n          cluster.update(this.motes); // Update position after merging\n          clustersToRemove.add(j);\n        }\n      }\n    }\n\n    // Remove marked clusters\n    for (let i = this.clusters.length - 1; i >= 0; i--) {\n      if (clustersToRemove.has(i)) {\n        this.clusters.splice(i, 1);\n      }\n    }\n  }\n\n  applyClusterDynamics(): void {\n    for (const cluster of this.clusters) {\n      for (const moteIndex of cluster.motes) {\n        const motePos = new Vector(\n          this.motes[moteIndex * 4],\n          this.motes[moteIndex * 4 + 1]\n        );\n        const distanceToCenter = Vector.dist(motePos, cluster.position);\n\n        // Apply cohesion force\n        let cohesionForce = cluster.position.sub(motePos);\n        const cohesionStrength = Math.min(\n          distanceToCenter * this.spec.clusterCohesionFactor,\n          this.spec.maxCohesionForce\n        );\n        cohesionForce = cohesionForce.setMag(cohesionStrength);\n\n        // Apply separation force\n        let separationForce = new Vector(0, 0);\n        if (distanceToCenter < this.spec.clusterSeparationRadius) {\n          separationForce = motePos.sub(cluster.position);\n          const separationStrength =\n            this.spec.clusterSeparationFactor *\n            (1 - distanceToCenter / this.spec.clusterSeparationRadius);\n          separationForce = separationForce.setMag(separationStrength);\n        }\n\n        // Apply alignment force (assuming we have a method to calculate cluster velocity)\n        const clusterVelocity = this.calculateClusterVelocity(cluster);\n        let alignmentForce = clusterVelocity.sub(\n          new Vector(\n            this.velocities[moteIndex * 2],\n            this.velocities[moteIndex * 2 + 1]\n          )\n        );\n        alignmentForce = alignmentForce.mult(this.spec.clusterAlignmentFactor);\n\n        // Combine forces\n        const totalForce = cohesionForce\n          .add(separationForce)\n          .add(alignmentForce);\n\n        // Apply the combined force\n        this.velocities[moteIndex * 2] += totalForce.x;\n        this.velocities[moteIndex * 2 + 1] += totalForce.y;\n      }\n    }\n  }\n\n  calculateClusterVelocity(cluster: Cluster): Vector {\n    let avgVelocity = new Vector(0, 0);\n    for (const moteIndex of cluster.motes) {\n      avgVelocity = avgVelocity.add(\n        new Vector(\n          this.velocities[moteIndex * 2],\n          this.velocities[moteIndex * 2 + 1]\n        )\n      );\n    }\n    return avgVelocity.mult(1 / cluster.motes.size);\n  }\n\n  // Handle collisions\n  private collide(a: number, b: number, d: number, v: Vector): void {\n    let forceFactor = this.spec.moteForce;\n    if (d >= this.spec.moteRadius - this.spec.moteCollisionDecay) {\n      forceFactor =\n        (this.spec.moteForce * (this.spec.moteRadius - d)) /\n        this.spec.moteCollisionDecay;\n    }\n    v = v.setMag(forceFactor);\n    this.velocities[a * 2] -= v.x;\n    this.velocities[a * 2 + 1] -= v.y;\n    this.velocities[b * 2] += v.x;\n    this.velocities[b * 2 + 1] += v.y;\n\n    // Increment collision counts\n    this.motes[a * 4 + 2]++;\n    this.motes[b * 4 + 2]++;\n  }\n}\n\nexport { MoteSimulator, Cluster };\n","import { dist, rescale, pi } from \"./safeMath.js\";\nimport { Rng } from \"./safeRandom.js\";\nimport { Spec } from \"./spec.js\";\nimport { Vector } from \"./vector.js\";\n\ntype DisturbanceSpec = {\n  pos: Vector;\n  theta: number;\n  radius: number;\n};\n\ntype FlowSpec = {\n  defaultTheta: number;\n  disturbances: DisturbanceSpec[];\n  bounds: Vector;\n};\n\nexport interface IFlowField {\n  flow(pos: Vector): Vector;\n}\n\nexport function flowSpec(r: Rng, spec: Spec, bounds: Vector): FlowSpec {\n  const { numDisturbances, thetaVariance, defaultTheta } = spec;\n  const disturbances: DisturbanceSpec[] = [];\n  for (let i = 0; i < numDisturbances; i++) {\n    const disturbanceX = r.uniform(0, bounds.x);\n    const disturbanceY = r.uniform(0, bounds.y);\n    const disturbanceTheta = r.gauss(0, thetaVariance);\n    const disturbanceRadius = Math.abs(\n      r.gauss(spec.disturbanceRadiusMean, spec.disturbanceRadiusVariance)\n    );\n    disturbances.push({\n      pos: new Vector(disturbanceX, disturbanceY),\n      theta: disturbanceTheta,\n      radius: disturbanceRadius,\n    });\n  }\n  return { defaultTheta, disturbances, bounds };\n}\n\nexport class FlowField {\n  spacing = 4;\n  fieldPoints: Float64Array[]; // Angle (theta) in a grid on the field\n\n  constructor(spec: FlowSpec) {\n    const iMax = Math.ceil(spec.bounds.x / this.spacing);\n    const jMax = Math.ceil(spec.bounds.y / this.spacing);\n    this.fieldPoints = Array.from({ length: iMax }, () =>\n      new Float64Array(jMax).fill(spec.defaultTheta)\n    );\n\n    for (const { pos, theta, radius } of spec.disturbances) {\n      const minX = pos.x - radius;\n      const maxX = pos.x + radius;\n      const minY = pos.y - radius;\n      const maxY = pos.y + radius;\n\n      const minI = Math.max(0, Math.floor(minX / this.spacing));\n      const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n      const minJ = Math.max(0, Math.floor(minY / this.spacing));\n      const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n\n      for (let i = minI; i < maxI; i++) {\n        const x = this.spacing * i;\n        for (let j = minJ; j < maxJ; j++) {\n          const y = this.spacing * j;\n          const d = dist(pos.x, pos.y, x, y);\n          const thetaAdjust = rescale(d, 0, radius, theta, 0);\n          this.fieldPoints[i][j] += thetaAdjust;\n        }\n      }\n    }\n  }\n\n  flow(pos: Vector): Vector {\n    const i = Math.floor(pos.x / this.spacing);\n    const j = Math.floor(pos.y / this.spacing);\n    const theta = this.fieldPoints[i][j];\n    return Vector.fromAngle(theta);\n  }\n}\n\ntype DynamicDisturbance = {\n  pos: Vector;\n  vel: Vector;\n  theta: number;\n  radius: number;\n};\n\nexport class DynamicFlowField {\n  spacing = 4;\n  numDisturbances = 30;\n  thetaVariance = 3.14;\n  disturbanceRadiusMean = 100;\n  disturbanceRadiusVariance = 200;\n  defaultTheta: number;\n\n  disturbances: DynamicDisturbance[] = [];\n  bounds: Vector;\n  rng: Rng;\n\n  fieldPoints: Float64Array[]; // Angle (theta) in a grid on the field\n\n  constructor(rng: Rng, bounds: Vector) {\n    this.rng = rng;\n    this.bounds = bounds;\n    this.defaultTheta = rng.uniform(0, pi(2));\n\n    this.fieldPoints = [];\n    this.disturbances = [];\n    while (this.disturbances.length < this.numDisturbances) {\n      this.addDisturbance();\n    }\n    this.computeFlowField();\n  }\n\n  inBounds(pos: Vector) {\n    return (\n      pos.x >= 0 &&\n      pos.x <= this.bounds.x &&\n      pos.y >= 0 &&\n      pos.y <= this.bounds.y\n    );\n  }\n\n  addDisturbance() {\n    const disturbanceX = this.rng.uniform(0, this.bounds.x);\n    const disturbanceY = this.rng.uniform(0, this.bounds.y);\n    const disturbanceTheta = this.rng.gauss(0, this.thetaVariance);\n    const disturbanceRadius = Math.abs(\n      this.rng.gauss(this.disturbanceRadiusMean, this.disturbanceRadiusVariance)\n    );\n    const disturbanceHeading = this.rng.uniform(0, pi(2));\n    const disturbanceSpeed = this.rng.uniform(0, 0.5);\n    const disturbanceVel =\n      Vector.fromAngle(disturbanceHeading).mult(disturbanceSpeed);\n    this.disturbances.push({\n      pos: new Vector(disturbanceX, disturbanceY),\n      vel: disturbanceVel,\n      theta: disturbanceTheta,\n      radius: disturbanceRadius,\n    });\n  }\n\n  computeFlowField() {\n    const iMax = Math.ceil(this.bounds.x / this.spacing);\n    const jMax = Math.ceil(this.bounds.y / this.spacing);\n    this.fieldPoints = Array.from({ length: iMax }, () =>\n      new Float64Array(jMax).fill(this.defaultTheta)\n    );\n\n    for (const { pos, theta, radius } of this.disturbances) {\n      const minX = pos.x - radius;\n      const maxX = pos.x + radius;\n      const minY = pos.y - radius;\n      const maxY = pos.y + radius;\n\n      const minI = Math.max(0, Math.floor(minX / this.spacing));\n      const maxI = Math.min(iMax, Math.ceil(maxX / this.spacing));\n      const minJ = Math.max(0, Math.floor(minY / this.spacing));\n      const maxJ = Math.min(jMax, Math.ceil(maxY / this.spacing));\n\n      for (let i = minI; i < maxI; i++) {\n        const x = this.spacing * i;\n        for (let j = minJ; j < maxJ; j++) {\n          const y = this.spacing * j;\n          const dx = pos.x - x;\n          const dy = pos.y - y;\n          const d = Math.sqrt(dx * dx + dy * dy);\n          const thetaAdjust = d <= radius ? theta * (1 - d / radius) : 0;\n          this.fieldPoints[i][j] += thetaAdjust;\n        }\n      }\n    }\n  }\n\n  step() {\n    for (const disturbance of this.disturbances) {\n      disturbance.pos.add(disturbance.vel);\n      if (!this.inBounds(disturbance.pos)) {\n        disturbance.vel.mult(-1);\n      }\n    }\n    this.computeFlowField();\n  }\n\n  flow(pos: Vector): Vector {\n    const i = Math.floor(pos.x / this.spacing);\n    const j = Math.floor(pos.y / this.spacing);\n    const theta = this.fieldPoints[i][j];\n    return Vector.fromAngle(theta);\n  }\n}\n","// Helpful math functions, adapted from safeMath.js in qql-art/frontend\n\nexport function pi(v: number): number {\n  return Math.PI * v;\n}\n\nexport function mod(n: number, m: number): number {\n  return ((n % m) + m) % m;\n}\n\nexport function snap(value: number, step: number): number {\n  return Math.round(value / step) * step;\n}\n\nexport function clip(\n  value: number,\n  min: number | null = null,\n  max: number | null = null\n) {\n  value = max !== null ? Math.min(value, max) : value;\n  value = min !== null ? Math.max(value, min) : value;\n  return value;\n}\n\nexport function rescale(\n  value: number,\n  oldMin: number,\n  oldMax: number,\n  newMin: number,\n  newMax: number\n) {\n  const clipped = clip(value, oldMin, oldMax);\n  const oldSpread = oldMax - oldMin;\n  const newSpread = newMax - newMin;\n  return newMin + (clipped - oldMin) * (newSpread / oldSpread);\n}\n\n// linear interpolation\nexport function lrp(start: number, end: number, t: number): number {\n  return start + (end - start) * t;\n}\n\nexport function average(...args: number[]): number {\n  return args.reduce((lhs, rhs) => lhs + rhs, 0) / args.length;\n}\n\nexport function sqrt(\n  value: number,\n  maxIterations = 1000,\n  epsilon = 1e-14,\n  target = 1e-7\n) {\n  if (value < 0) {\n    throw new Error(\"Value must be non-negative.\");\n  }\n\n  let guess = value;\n  for (let index = 0; index < maxIterations; index++) {\n    const error = guess * guess - value;\n    if (Math.abs(error) <= target) {\n      return guess;\n    }\n\n    const divisor = 2 * guess;\n    if (divisor <= epsilon) {\n      return guess;\n    }\n\n    guess -= error / divisor;\n  }\n\n  return guess;\n}\n\nexport function dist(x1: number, y1: number, x2: number, y2: number) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return sqrt(dx * dx + dy * dy);\n}\n\n// \"Fast\" atan2 implementation using a polynomial approximation.\n// Adapted from https://stackoverflow.com/questions/46210708.\nexport function atan2(y: number, x: number): number {\n  const ax = Math.abs(x);\n  const ay = Math.abs(y);\n  const mx = Math.max(ay, ax);\n  const mn = Math.min(ay, ax);\n  const a = mn / mx;\n  /* Minimax polynomial approximation to atan(a) on [0,1] */\n  const s = a * a;\n  const c = s * a;\n  const q = s * s;\n  let r = 0.024840285 * q + 0.18681418;\n  let t = -0.094097948 * q - 0.33213072;\n  r = r * s + t;\n  r = r * c + a;\n  /* Map to full circle */\n  if (ay > ax) r = 1.57079637 - r;\n  if (x < 0) r = 3.14159274 - r;\n  if (y < 0) r = -r;\n  return r;\n}\n\n// Build an interpolation-based lookup function from a given table.\n// The function is assumed period, so given values outside the range will wrap.\nfunction buildInterpolator(table: number[], min: number, max: number) {\n  return (value: number) => {\n    // Coerce value to [min, max) assuming periodicity.\n    value = mod(value - min, max - min) + min;\n\n    const rescaled = rescale(value, min, max, 0, table.length - 1);\n    const index = Math.floor(rescaled); // This is within [0, table.length - 1).\n    const fraction = rescaled - index; // This is within [0, 1).\n\n    // Function evaluated at value is within [start, end) based on index.\n    const start = table[index];\n    const end = table[index + 1];\n\n    // Interpolate within [start, end) using fractional part.\n    return lrp(start, end, fraction);\n  };\n}\n\nconst cosTable = [\n  1.0, 0.99179, 0.96729, 0.92692, 0.87132, 0.80141, 0.71835, 0.62349, 0.51839,\n  0.40478, 0.28453, 0.1596, 0.03205, -0.09602, -0.22252, -0.34537, -0.46254,\n  -0.57212, -0.6723, -0.76145, -0.83809, -0.90097, -0.94906, -0.98156, -0.99795,\n  -0.99795, -0.98156, -0.94906, -0.90097, -0.83809, -0.76145, -0.6723, -0.57212,\n  -0.46254, -0.34537, -0.22252, -0.09602, 0.03205, 0.1596, 0.28453, 0.40478,\n  0.51839, 0.62349, 0.71835, 0.80141, 0.87132, 0.92692, 0.96729, 0.99179, 1.0,\n];\n\nexport const cos = buildInterpolator(cosTable, 0, 2 * Math.PI);\n\nconst sinTable = [\n  0.0, 0.12788, 0.25365, 0.37527, 0.49072, 0.59811, 0.69568, 0.78183, 0.85514,\n  0.91441, 0.95867, 0.98718, 0.99949, 0.99538, 0.97493, 0.93847, 0.8866,\n  0.82017, 0.74028, 0.64823, 0.54553, 0.43388, 0.31511, 0.19116, 0.06407,\n  -0.06407, -0.19116, -0.31511, -0.43388, -0.54553, -0.64823, -0.74028,\n  -0.82017, -0.8866, -0.93847, -0.97493, -0.99538, -0.99949, -0.98718, -0.95867,\n  -0.91441, -0.85514, -0.78183, -0.69568, -0.59811, -0.49072, -0.37527,\n  -0.25365, -0.12788, -0.0,\n];\n\nexport const sin = buildInterpolator(sinTable, 0, 2 * Math.PI);\n\nexport function angle(x1: number, y1: number, x2: number, y2: number): number {\n  const a = atan2(y2 - y1, x2 - x1);\n  return mod(a, pi(2.0));\n}\n\n// Fast upper bound of `dist()` function.\nexport function distUpperBound(x1: number, y1: number, x2: number, y2: number) {\n  const dx = Math.abs(x1 - x2);\n  const dy = Math.abs(y1 - y2);\n\n  const min = Math.min(dx, dy);\n  const max = Math.max(dx, dy);\n\n  const alpha = 1007 / 1110;\n  const beta = 441 / 1110;\n\n  return alpha * max + beta * min;\n}\n\n// Fast lower bound of `dist()` function.\nexport function distLowerBound(x1: number, y1: number, x2: number, y2: number) {\n  const dx = Math.abs(x1 - x2);\n  const dy = Math.abs(y1 - y2);\n\n  const min = Math.min(dx, dy);\n  const max = Math.max(dx, dy);\n\n  const beta = 441 / 1024;\n\n  return max + beta * min;\n}\n\nexport function addPolarOffset(\n  x: number,\n  y: number,\n  theta: number,\n  magnitude: number\n): number[] {\n  return [x + magnitude * cos(theta), y + magnitude * sin(theta)];\n}\n","export class Vector {\n  readonly x: number;\n  readonly y: number;\n\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n  }\n\n  add(v: Vector): Vector {\n    return new Vector(this.x + v.x, this.y + v.y);\n  }\n\n  sub(v: Vector): Vector {\n    return new Vector(this.x - v.x, this.y - v.y);\n  }\n\n  mult(scalar: number): Vector {\n    return new Vector(this.x * scalar, this.y * scalar);\n  }\n\n  angle(): number {\n    return Math.atan2(this.y, this.x);\n  }\n\n  setMag(magnitude: number): Vector {\n    const angle = this.angle();\n    return new Vector(Math.cos(angle) * magnitude, Math.sin(angle) * magnitude);\n  }\n\n  static fromAngle(angle: number): Vector {\n    return new Vector(Math.cos(angle), Math.sin(angle));\n  }\n\n  static dist(v1: Vector, v2: Vector): number {\n    return Math.sqrt((v1.x - v2.x) ** 2 + (v1.y - v2.y) ** 2);\n  }\n\n  // Serialize the Vector to a plain object\n  toJSON() {\n    return { x: this.x, y: this.y };\n  }\n\n  // Deserialize a plain object to a Vector\n  static fromJSON(json: { x: number; y: number }): Vector {\n    return new Vector(json.x, json.y);\n  }\n}\n","import randomSeed from \"./randomSeed\";\n\n// Note that the index order [0, 1, 2, 3] is little-endian\nconst eps = Math.pow(2, -32),\n  m0 = 0x7f2d,\n  m1 = 0x4c95,\n  m2 = 0xf42d,\n  m3 = 0x5851, // 6364136223846793005\n  a0 = 0x814f,\n  a1 = 0xf767,\n  a2 = 0x7b7e,\n  a3 = 0x1405; // 1442695040888963407\n\nexport function makeSeededRng(hash: string /*: bytes32 */) /*: Rng */ {\n  const rng = new Rng();\n  rng.setSeed(hash);\n  return rng;\n}\n\nexport function makeUnseededRng() /*: Rng */ {\n  return makeSeededRng(randomSeed());\n}\n\nexport class Rng {\n  _state: Uint16Array;\n  _dv: DataView;\n  _nG: number | null;\n  _hNG: boolean;\n\n  constructor() {\n    this._state = new Uint16Array(4);\n    this._dv = new DataView(this._state.buffer);\n    this._nG = null; // nextGaussian\n    this._hNG = false; // hasNextGaussian\n  }\n\n  // sets the seed to a tokenData hash string \"0x...\"\n  setSeed(hash: string) {\n    this._hNG = false;\n    this._nG = null;\n    const nBytes = ~~((hash.length - 2) / 2);\n    const bytes: number[] = [];\n    for (let j = 0; j < nBytes; j++) {\n      const e0 = 2 + 2 * j;\n      bytes.push(parseInt(hash.slice(e0, e0 + 2), 16));\n    }\n\n    // to keep it simple, we just use 32bit murmur2 with two different seeds\n    const seed_a = 1690382925;\n    const seed_b = 72970470;\n    const lower = hash32(bytes, seed_a);\n    const upper = hash32(bytes, seed_b);\n    this._dv.setUint32(0, lower);\n    this._dv.setUint32(4, upper);\n  }\n\n  // random value between 0..1\n  rnd() {\n    const state = this._state;\n    // Advance internal state\n    const s0 = state[0],\n      s1 = state[1],\n      s2 = state[2],\n      s3 = state[3],\n      new0 = (a0 + m0 * s0) | 0,\n      new1 = (a1 + m0 * s1 + (m1 * s0 + (new0 >>> 16))) | 0,\n      new2 = (a2 + m0 * s2 + m1 * s1 + (m2 * s0 + (new1 >>> 16))) | 0,\n      new3 = a3 + m0 * s3 + (m1 * s2 + m2 * s1) + (m3 * s0 + (new2 >>> 16));\n    (state[0] = new0), (state[1] = new1), (state[2] = new2);\n    state[3] = new3;\n\n    // Calculate output function (XSH RR), uses old state\n    const xorshifted =\n        (s3 << 21) + (((s3 >> 2) ^ s2) << 5) + (((s2 >> 2) ^ s1) >> 11),\n      out_int32 =\n        (xorshifted >>> (s3 >> 11)) | (xorshifted << (-(s3 >> 11) & 31));\n    return eps * (out_int32 >>> 0);\n  }\n\n  // random value between min (inclusive) and max (exclusive)\n  uniform(min = 1, max: number | null = null) {\n    if (max === null) {\n      [min, max] = [0, min];\n    }\n    return this.rnd() * (max - min) + min;\n  }\n\n  // random gaussian distribution\n  gauss(mean = 0, variance = 1) {\n    // https://github.com/openjdk-mirror/jdk7u-jdk/blob/f4d80957e89a19a29bb9f9807d2a28351ed7f7df/src/share/classes/java/util/Random.java#L496\n    if (this._hNG) {\n      this._hNG = false;\n      var result = this._nG as number;\n      this._nG = null;\n      return mean + variance * result;\n    } else {\n      var v1 = 0;\n      var v2 = 0;\n      var s = 0;\n      do {\n        v1 = this.rnd() * 2 - 1; // between -1 and 1\n        v2 = this.rnd() * 2 - 1; // between -1 and 1\n        s = v1 * v1 + v2 * v2;\n      } while (s >= 1 || s === 0);\n      var multiplier = Math.sqrt((-2 * Math.log(s)) / s);\n      this._nG = v2 * multiplier;\n      this._hNG = true;\n      return mean + variance * (v1 * multiplier);\n    }\n  }\n\n  odds(p: number) {\n    return this.uniform() <= p;\n  }\n\n  choice<T>(items: T[]): T {\n    return items[Math.floor(this.uniform(0, items.length))];\n  }\n\n  weightedChoice<T>(items: [T, number][]) {\n    const sumWeight = items\n      .map(([, weight]) => weight)\n      .reduce((lhs, rhs) => lhs + rhs, 0);\n    const bisection = sumWeight * this.uniform();\n\n    let cumWeight = 0;\n    for (let index = 0; index < items.length; index++) {\n      const [value, weight] = items[index];\n      cumWeight += weight;\n      if (cumWeight >= bisection) {\n        return value;\n      }\n    }\n\n    const [lastValue] = items[items.length - 1];\n    return lastValue;\n  }\n\n  // alias for weightedChoice\n  wc<T>(items: [T, number][]) {\n    return this.weightedChoice(items);\n  }\n\n  // a version of shuffle that safely uses our PRNG\n  shuffle<T>(items: T[]): T[] {\n    const joined: [number, T][] = items.map((item) => [\n      this.uniform(0.0, 1.0),\n      item,\n    ]);\n\n    joined.sort((a, b) => {\n      return a[0] < b[0] ? -1 : 1;\n    });\n\n    return joined.map(([, item]) => item);\n  }\n\n  // returns a copy of the array that has been \"winnowed\" down to contain at most `num`\n  // entries, while preserving the original order\n  winnow<T>(input: T[], num: number): T[] {\n    const items = input.slice();\n    while (items.length > num) {\n      const index = Math.floor(this.rnd() * items.length);\n      items.splice(index, 1);\n    }\n    return items;\n  }\n}\n\n// internally gets a 32-bit from tokenData hash bytes\nfunction hash32(bytes: number[], seed = 0) {\n  // murmur2 32bit\n  // https://github.com/garycourt/murmurhash-js/blob/master/murmurhash2_gc.js\n  const K = 16;\n  const mask = 65535;\n  const maskByte = 0xff;\n  var m = 0x5bd1e995;\n  var l = bytes.length,\n    h = seed ^ l,\n    i = 0,\n    k;\n  while (l >= 4) {\n    k =\n      (bytes[i] & maskByte) |\n      ((bytes[++i] & maskByte) << 8) |\n      ((bytes[++i] & maskByte) << 16) |\n      ((bytes[++i] & maskByte) << 24);\n    k = (k & mask) * m + ((((k >>> K) * m) & mask) << K);\n    k ^= k >>> 24;\n    k = (k & mask) * m + ((((k >>> K) * m) & mask) << K);\n    h = ((h & mask) * m + ((((h >>> K) * m) & mask) << K)) ^ k;\n    l -= 4;\n    ++i;\n  }\n  /* eslint-disable no-fallthrough */\n  switch (l) {\n    case 3:\n      h ^= (bytes[i + 2] & maskByte) << K;\n    case 2:\n      h ^= (bytes[i + 1] & maskByte) << 8;\n    case 1:\n      h ^= bytes[i] & maskByte;\n      h = (h & mask) * m + ((((h >>> K) * m) & mask) << K);\n  }\n  /* eslint-enable no-fallthrough */\n  h ^= h >>> 13;\n  h = (h & mask) * m + ((((h >>> K) * m) & mask) << K);\n  h ^= h >>> 15;\n  return h >>> 0;\n}\n","// picks a uniformly random `bytes32` using JS Math.random state\n// (i.e., not itself seeded by `safe-random.js`)\nexport default function randomSeed(): string {\n  let nibbles = Array(64)\n    .fill(0)\n    .map(() => Math.floor(Math.random() * 16).toString(16));\n  return \"0x\" + nibbles.join(\"\");\n}\n"],"names":["$11e94a6f2f3cd93d$var$simulator","$4c550ce18ec8f877$var$buildInterpolator","table","min","max","value","m","rescaled","$4c550ce18ec8f877$export$bd2782c820638828","oldMin","oldMax","newMin","newMax","clipped","$4c550ce18ec8f877$export$e0b576e7a74416cd","Math","$4c550ce18ec8f877$export$842a2cf37af977e1","n","length","index","floor","start","end","PI","$03e8730a80c32c61$export$9b781de7bf37bf48","constructor","x","y","add","v","sub","mult","scalar","angle","atan2","setMag","magnitude","cos","sin","fromAngle","dist","v1","v2","sqrt","toJSON","fromJSON","json","$1aa6a5cda7d913a4$export$6277d9167271f79d","rng","bounds","spacing","numDisturbances","thetaVariance","disturbanceRadiusMean","disturbanceRadiusVariance","disturbances","defaultTheta","uniform","fieldPoints","addDisturbance","computeFlowField","inBounds","pos","disturbanceX","disturbanceY","disturbanceTheta","gauss","disturbanceRadius","abs","disturbanceHeading","disturbanceSpeed","disturbanceVel","push","vel","theta","radius","iMax","ceil","jMax","Array","from","Float64Array","fill","minX","maxX","minY","maxY","minI","maxI","minJ","maxJ","i","j","dx","dy","d","thetaAdjust","step","disturbance","flow","$ba609055bbdbfded$export$b15cd8f5723f9e05","_state","Uint16Array","_dv","DataView","buffer","_nG","_hNG","setSeed","hash","nBytes","bytes","e0","parseInt","slice","lower","$ba609055bbdbfded$var$hash32","upper","setUint32","rnd","state","s0","s1","s2","s3","new0","$ba609055bbdbfded$var$a0","$ba609055bbdbfded$var$m0","new1","$ba609055bbdbfded$var$a1","$ba609055bbdbfded$var$m1","new2","$ba609055bbdbfded$var$a2","$ba609055bbdbfded$var$m2","new3","$ba609055bbdbfded$var$a3","$ba609055bbdbfded$var$m3","xorshifted","$ba609055bbdbfded$var$eps","out_int32","mean","variance","result","s","multiplier","log","odds","p","choice","items","weightedChoice","bisection","sumWeight","map","weight","reduce","lhs","rhs","cumWeight","lastValue","wc","shuffle","joined","item","sort","a","b","winnow","input","num","splice","seed","k","l","h","K","$8c085251956c254b$export$57ed47926628b770","initialMote","initialPosition","position","motes","Set","update","sum","moteIndex","size","cluster","$8c085251956c254b$export$4cd0859bc913b350","spec","xDim","yDim","clusters","stepCounter","xMax","yMax","flowField","nMotes","numMotes","Float32Array","velocities","Date","now","reset","processCollisions","updateClusters","applyClusterDynamics","moveMotes","gridSize","moteRadius","grid","Map","radiusSq","flatMap","clusterMap","forEach","mote","set","key","has","get","motesInCell","entries","split","Number","neighborKey","neighborMotes","potentialCluster","isNewCluster","jx","jy","dsq","cdx","cdy","cdSq","collide","clusterRadius","clusterSize","flowVector","nCollisions","flowCoefficient","pow","cxFlowCoefficient","clustersToRemove","motePos","delete","clusterCollapseSize","otherCluster","distanceToCenter","cohesionForce","cohesionStrength","clusterCohesionFactor","maxCohesionForce","separationForce","clusterSeparationRadius","separationStrength","clusterSeparationFactor","alignmentForce","clusterVelocity","calculateClusterVelocity","clusterAlignmentFactor","totalForce","avgVelocity","forceFactor","moteForce","moteCollisionDecay","self","onmessage","e","type","data","motesBuffer","postMessage"],"version":3,"file":"moteSimulationWorker.85c05332.js.map"}